#include <iostream>
#include <cstring>
using namespace std;

int R,C,M;
struct info{ // 구조체 형성 정보형성에 유용하다. 
	int s,d,z;
};
info arr[100][100]; // 구조체 배열 확실히 알고 사용해야한다 . 

int dy[4] = {-1,1,0,0}; //위 아래 오른쪽 왼쪽  지문에서 방향을 정해주었기 때문에 그대로 -1한 인덱스로 받는다. 
int dx[4] = {0,0,1,-1};

int solve(){
	info backup[100][100];// 매 초가 지나고나면 새로운 판을 미리 복사 해놓아야한다.
	
	int sum = 0;// 상어들을 하나씩 담을 변수  
	
	for(int i=0; i < C ; ++i ){ // 1초에 한칸씩 옮겨간다. 
		for(int j=0 ;j < R ; ++j){
			if(arr[j][i].z > 0){
				sum += arr[j][i].z; //잡기전에 상어의 크기를 추가해서 더해준다. 
				arr[j][i].z = 0; ///상어응 잡는다. 
				break; // 차례대로 탐색해서 제일 가까운 상어를 잡아먹기 때문에 먹으면 그 열에서 바로 빠져나온다. 
			}
		}
		memcpy(backup,arr,sizeof(arr));
		memset(arr,0,sizeof(arr)); // memset만 0으로 셋팅가능하다.  // 이런 사소한 실수 하지말자. 
		for(int k = 0;k < R; ++k){
			for(int t = 0;t < C; ++t){ 
				info& cur = backup[k][t]; // 지금 원본에 있는 데이터와 나중에 들어갈 정보와 비교하기 위해서  . 레퍼런스는 원본의 값을 마음대로 변경가능하다. 
				if(cur.z > 0){
					int ns = cur.s; // 이렇게되면 cur의 정보는 그대로고 다른 변수만 변동되어서 전혀 영향이 없다. 
					int nd = cur.d; // 아니면 cur을 넣어주는게 아니라 새로운 nd ns nz를 넣어주면된다. 
					int nz = cur.z; // 정보변경의 일관성을 유지시키는 게 중요하다. 
					int ny = k + ns * dy[nd]; // 해당방향으로 자신의 속력만큼 이동한다. 
					int nx = t + ns * dx[nd]; // 다 새로운 변수로 설정해주는 것이좋다 정보이동 변경 수정인 경우  
					if(ny < 0){ // 위로 넘어가는 방향이다.  
						ny = -ny; // 양수로 바꾼다 어차피 0부터 시작하게되어 있다 위에서 계산한값은 0으로 셋팅된다. 
						nd = 1; //방향 전환해준다.  // 아래로가는 방향으로 바꿔준다. 
					}
					if(ny >= R){ // 음수를 양수로 바꾼다움에 처리한다.  // 양수로 바꾼다는 것은 아래로 가는 방향을 뜻한다. 
						//항상 변수 변수를 따로 저장하는 습관을 들여라 
						// 정보 변경시에 
						int a =  ny / (R-1); // 복잡하고 반복되는 경우는 이렇게 따로 변수에 저장한다. 
						int b =  ny % (R-1);
						if( (a % 2) == 0){
							ny = b;
						} 
						else{
							ny = (R-1) - b;
							nd = 0; // 홀수이면 방향이 바뀐다.//위아래로 바뀌는 것이다. 
						} 
					}
					if(nx < 0){ // 양수로 바꾼다는 것은 오른쪽으로 바꾼다는 것이다. 
						nx = -nx; 
						nd = 2; // 오른쪽방향으로 바꾼다. 
					}
					if(nx >= C){   // 복붙해줄 때는 변수 바꾸는 거 신경 써줘야한다. 
						int c = nx/(C-1);
						int d = nx%(C-1);
						if((c % 2)== 0){
							nx = d;
						} 
						else{
							nx = (C-1)-d;
							nd = 3; // 홀수이면 왼쪽 방향을 바꿔서 저장한다. 
						} 
					}
					// 위치가 정해지면 새로운 맵에 저장하면 된다.
					//상어가 이미 있는 경우 생각해야한다.
					if(arr[ny][nx].z < nz) //현재정보가 전에 있는 원래 정보보다 크기가 크다면  
						arr[ny][nx] = {ns,nd,nz}; // 이렇게 전에 있는 정보와 현재있는 정보를 비교 변경할 수 있다. 
				}
			}
		} // 여기까지가 1초동안 상어를 잡고 상어들이 이동하는 순간까지다. 
		
	}	
	
	return sum;
}
int main(){
	cin >> R >> C >> M;
	for(int i=0;i < M; ++i){
		
		int r,c,s,d,z;
		cin >> r >> c >> s >> d >> z;
		--r;
		--c;
		--d;
		arr[r][c] = {s,d,z}; // 한칸에 상어의정보를 꾸역꾸역 집어 넣는다. 
	}
	
	cout<< solve() << endl;
	
	
}
